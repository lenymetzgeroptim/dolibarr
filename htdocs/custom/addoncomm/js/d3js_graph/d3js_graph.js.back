


    // Fonction pour cr√©er un graphique de type radial
    function createChart(data, selectedYear) {
        // Supprimer l'ancien graphique et la l√©gende
        d3.select("#chart").selectAll("*").remove();
        d3.select("#legend-container").selectAll("*").remove();
        d3.select('svg').selectAll("*").remove();
        
        const numAgences = new Set(data.map(d => d.agence)).size;
        const numDomaines = new Set(data.map(d => d.domaine)).size;
        
        // Dimensions dynamiques pour le graphique
        const width = Math.max(600, numAgences * 40);
        const heightGraph = Math.max(650, numAgences * 80);
        const innerRadius = 50;
        const outerRadius = Math.min(width, heightGraph) / 2 - 20;
        
        // Regrouper les donn√©es par agence
        const groupedData = d3.groups(data, d => d.agence);
        
        // R√©cup√©rer tous les domaines uniques
        const domaineKeys = Array.from(new Set(data.flatMap(d => d.domaine)));
        
        // Pr√©paration des donn√©es group√©es sans domaines vides
        const stackedData = groupedData.map(([agence, values]) => {
            const entry = { agence };
            domaineKeys.forEach(domaine => {
                const montant1 = values.find(v => v.domaine === domaine)?.montant1 || 0.0;
                entry[domaine] = montant1;
                entry.color = values.find(v => v.domaine === domaine)?.color || '';
            });
            return entry;
        });
        
        const series = d3.stack()
            .keys(domaineKeys)
            (stackedData);
        
        const x = d3.scaleBand()
            .domain(stackedData.map(d => d.agence))
            .range([0, 2 * Math.PI])
            .align(0);
        
        const y = d3.scaleRadial()
            .domain([0, d3.max(series, d => d3.max(d, d => d[1]))])
            .range([innerRadius, outerRadius]);
        
        // const hasValidData = data && data.some(d => d.montant1 > 0);
        
        // if (hasValidData) {
        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", "100%")
            .attr("height", heightGraph + 20)
            .attr("viewBox", "0 0 " + width + " " + (heightGraph + 50));
    
            const fontSize = selectedYear.length > 5 ? "14px" : "20px"; // Si la longueur est > 5, font-size = 8px, sinon 20px
            let displayText = selectedYear;
            if (selectedYear.length > 5) {
                // Split √† l'endroit du tiret et retourner √† la ligne
                const parts = selectedYear.split(' - ');
                displayText = ' P√©riode : ' + parts[0] + " - "  + parts[1];  
            }
            // Ajout du libell√© pour l'ann√©e s√©lectionn√©e
            svg.append("text")
            .attr("x", -15) 
            .attr("y", 40) 
            .attr("class", "selected-year-label")
            .style("font-size", fontSize) 
            .style("font-weight", "600") 
            .style("font-family", "'Poppins', sans-serif") 
            .style("fill", "#0056b3") 
            // .style("text-shadow", "1px 1px 3px rgba(0, 0, 0, 0.3)") 
            .html('üìÖ' + displayText);
    
    
    
        const chartGroup = svg.append("g")
            .attr("transform", "translate(" + (width / 2) + "," + (heightGraph / 1.8) + ") scale(1.2, 1.2)");
    
        const arcGroups = chartGroup.selectAll("g")
            .data(series)
            .join("g")
            .attr("class", "arc-group");
    
        arcGroups.selectAll("path")
            .data(d => d.slice().sort((a, b) => {
                const valueA = a[1] - a[0];
                const valueB = b[1] - b[0];
                return valueA === 0 ? 1 : valueB === 0 ? -1 : 0;
            }))
            .join("path")
            .attr("fill", d => {
                const agence = d.data.agence;
                const montantCalcule = parseFloat((d[1] - d[0]).toFixed(2));
                const domaine = Object.keys(d.data).find(key => {
                    const montantDomaine = parseFloat(d.data[key]);
                    return montantDomaine === montantCalcule && key !== 'agence' && key !== 'color';
                });
                const foundData = data.find(item => item.agence === agence && item.domaine === domaine);
                return foundData ? foundData.color : "#ccc";  
            })
            .attr("d", d3.arc()
            .innerRadius(d => y(d[0]))
            .outerRadius(d => y(d[1]))
            .startAngle(d => x(d.data.agence))
            .endAngle(d => x(d.data.agence) + x.bandwidth())
            .padAngle(0.01) // Ajout d'un espacement entre les agences
        );
    
        // Ajouter les labels d'agence
        const uniqueAgences = new Set();
        arcGroups.selectAll("text")
            .data(d => d)
            .join("text")
            .attr("transform", d => {
                const angle = (x(d.data.agence) + x.bandwidth() / 2) * (180 / Math.PI) - 90;
                const radius = (y(d[0]) + y(d[1])) / 2 + 10;
                return 'translate(' + (Math.cos(angle * (Math.PI / 180)) * radius) + ', ' + (Math.sin(angle * (Math.PI / 180)) * radius) + ')';
            })
            .attr("dy", "0.35em")
            .text(d => {
                const agence = d.data.agence;
                if (!uniqueAgences.has(agence)) {
                    uniqueAgences.add(agence);
                    return agence;
                }
                return '';
            })
            .style("text-anchor", "middle")
            .style("font-size", "12px")
            .style("fill", "white");
    
        // Ajout de l'infobulle avec les d√©tails
        arcGroups.selectAll("path")
            .append("title")
            .text(d => {
                const montantCalcule = parseFloat((d[1] - d[0]).toFixed(2));
                const agence = d.data.agence || 'Aucune Agence';
                const domaine = Object.keys(d.data).find(key => d.data[key] === montantCalcule && key !== 'agence' && key !== 'color');
                const montant1 = d.data[domaine] !== undefined ? d.data[domaine] : 0;
                return agence + " - " + domaine + ": " + montant1 + "‚Ç¨";
            });
    
        // L√©gende dynamique structur√©e par agence
        const legendContainer = d3.select("#legend-container");
    
        // Regrouper les donn√©es par agence
        const groupedLegendData = d3.groups(data, d => d.agence);
    
        legendContainer.selectAll(".agency-legend")
        .data(groupedLegendData)
        .enter()
        .append("div")
        .attr("class", "agency-legend")
        .style("margin", "10px 0")
        .style("padding", "10px")
        .style("width", "90%")
        .style("background-color", "#f9f9f9")
        .each(function([agence, items]) {
            // Titre de l'agence
            d3.select(this).append("div")
                .attr("class", "agency-title")
                .style("font-weight", "bold")
                .style("font-size", "14px")
                .style("margin-bottom", "5px")
                .text(agence);
    
            // L√©gende pour chaque domaine de l'agence
            const domainContainer = d3.select(this).append("div")
                .attr("class", "domain-legend")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("justify-content", "flex-start"); // Alignement des √©l√©ments √† gauche
    
            domainContainer.selectAll(".legend-item")
                .data(items)
                .enter()
                .append("div")
                .attr("class", "legend-item")
                .style("display", "flex")
                .style("align-items", "center") // Assurez-vous que les √©l√©ments sont align√©s verticalement
                .style("margin", "5px 10px")
                .each(function(d) {
                    // Carr√© de couleur pour chaque domaine avec taille fixe
                    d3.select(this).append("div")
                        .style("width", "15px")   
                        .style("height", "15px")  
                        .style("background-color", getDomainColor(d.agence, d.domaine, data))
                        .style("margin-right", "8px")
                        .style("flex-shrink", "0"); // Emp√©che le carr√© de se r√©tr√©ci
 
                    // Texte du domaine et montant
                    d3.select(this).append("div")
                        .style("font-size", "12px")
                        .style("flex-grow", "1")  // Permet au texte de s'√©tirer sans affecter le carr√©
                        .style("font-family", "Arial, sans-serif")
                        // .style("line-height", "12px")
                        .style("text-align", "left")
                        .text(d.domaine + ": " + formatMontant(d.montant1) + "‚Ç¨");
                });
        });
        // return;
    // }
    // renderChartOrEmpty(data, selectedYear);
    }

    // Fonction pour cr√©er un graphique de type bar
    function createInvertedBarChart(data, selectedYear) {
        // Suppression du graphique pr√©c√©dent
        d3.select("#chart").html("");
        d3.select('svg').selectAll("*").remove();
        
        const width = 928; // Largeur fixe du graphique
        const marginTop = 30;
        const marginRight = 10;
        const marginBottom = 60;
        let marginLeft = 30; // On le rend dynamique
    
        // Grouper les donn√©es par agence
        const dataByAgence = d3.group(data, d => d.agence);
        const normalizedData = [];
    
    
    
        const agences = Array.from(dataByAgence.keys());
        const domaines = Array.from(new Set(data.map(d => d.domaine))); // Liste des domaines uniques
    
        const totalM1 = Array.from(new Set(data.map(d => d.montant1)));
        const totalM2 = Array.from(new Set(data.map(d => d.montant2))).filter(value => value == 0);
        // Calculer la somme des montants pour chaque agence
        const maxSum = d3.max(Array.from(dataByAgence.values()), agenceData => {
            return d3.sum(agenceData, d => d.montant2, d => d.montant1); // Somme des montants1 et montant2 pour chaque agence
        });
    
        // Calculer la largeur dynamique de `marginLeft`
        const tempSvg = d3.select("body").append("svg"); // SVG temporaire pour mesurer
        const maxLabelWidth = Math.max(...agences.map(agence => {
            const textElement = tempSvg.append("text")
                .attr("font-size", "12px")
                .text(agence);
            const width = textElement.node().getBBox().width;
            textElement.remove(); // Supprime le texte temporaire
            return width;
        }));
        tempSvg.remove(); // Suppression du SVG temporaire
    
        marginLeft = maxLabelWidth + 10; // Ajout d'un espace de 10 px apr√©s le texte
    
        // Suite du code avec le `marginLeft` dynamique
        const height = 20 * domaines.length + marginTop + marginBottom;
        const barHeight = Math.max(30, (height - marginTop - marginBottom) / domaines.length); // Ajustement de la hauteur des barres
    
        const x = d3.scaleLinear()
            .domain([0, maxSum])  // Utilisation de la somme maximale pour l'√©chelle
            .range([marginLeft, width - marginRight]);
    
            const isExist = height < 320; // si le nombre de domaines est impair
        
            const y = d3.scaleBand()
                .domain(agences)
                .range([marginTop, isExist ? height + marginBottom - 30 : height - marginBottom + 60]) // Ajust de la plage selon impair/pair
                .padding(isExist ? 0.3 : 0.4); // Ajuste le padding selon impair/pair
    
        // const y = d3.scaleBand()
        // .domain(agences)
        // .range([marginTop, height + marginBottom]) // Ajust de la plage selon impair/pair
        // .padding(0.3);
    
        // Cr√©ation d'un dictionnaire de couleurs bas√© sur les domaines (si chaque domaine a une couleur sp√©cifique dans les donn√©es, sinon une g√©n√©ration automatique d'uen couleur)
        const color = d3.scaleOrdinal()
            .domain(domaines)
            .range(domaines.map(domaine => {
                // Ici on suppose que chaque domaine dans 'data' a une propri√©t√© 'color'
                const domaineData = data.find(d => d.domaine === domaine);
                
                return domaineData ? domaineData.color : d3.schemeCategory10[domaines.indexOf(domaine) % d3.schemeCategory10.length]; // Couleur par d√©faut
            }));
        
    
        const svg = d3.select("#chart").append("svg")
            .attr("width", width)
            .attr("height", height + marginBottom)
            .attr("viewBox", [0, 0, width, height + marginBottom])
            .attr("style", "max-width: 100%; height: auto;");
            
            const fontSize = selectedYear.length > 5 ? "14px" : "20px";
            let displayText = selectedYear;
                if (selectedYear.length > 5) {
                    // Split √† l'endroit du tiret et retourner √† la ligne
                    const parts = selectedYear.split(' - ');
                    displayText = ' P√©riode : ' + parts[0] + " - "  + parts[1]; 
                }
            // Ajout du libell√© pour l'ann√©e s√©lectionn√©e
            svg.append("text")
            .attr("x", width - marginRight) 
            .attr("y", height - marginBottom + marginBottom + 40) 
            .attr("class", "selected-year-label")
            .style("font-size", fontSize) 
            .style("font-weight", "600") 
            .style("font-family", "'Poppins', sans-serif") 
            .style("fill", "#0056b3") 
            .style("text-anchor", "end")  // Alignement √† droite
            .html('üìÖ' + displayText);
        
            const groupSpacing = 50;
        // Cr√©ation d'une barre pour chaque agence et chaque domaine pour 'montant1' et 'montant2'
        dataByAgence.forEach((values, agence) => {
        
            const agencesGroup = svg.append("g")
            .attr("transform", `translate(0, ${y(agence)})`);
                // .attr("transform", "translate(0," + y(agence) + ")");
    
            // Calcul de la somme des montants1 et montants2 pour chaque agence
            const totalMontant1 = d3.sum(values, d => d.montant1);
            const totalMontant2 = d3.sum(values, d => d.montant2);
    
            // Calcul de la diff√©rence en pourcentage pour l'agence
            const differenceAgence = totalMontant1 - totalMontant2;
            const percentageDifferenceAgence = totalMontant1 === 0 ? 0 : (differenceAgence / totalMontant1) * 100;
            const formattedPercentageAgence = percentageDifferenceAgence.toFixed(1) + "%";
    
            const percentageRentabiliteRecette = totalMontant1 === 0 ? 0 : (differenceAgence / totalMontant1) * 100;
            const formattedRentabiliteRecette = percentageRentabiliteRecette.toFixed(1) + "%";
    
            let currentX1 = 0; // D√©but de la position horizontale pour la barre montant1
            let currentX2 = 0; // D√©but de la position horizontale pour la barre montant2
        
    
            values.forEach(d => {
                // Calcul de la diff√©rence en pourcentage
                const difference = d.montant1 - d.montant2;
                const percentageDifference = d.montant1 === 0 ? 0 : (difference / d.montant1) * 100;  // √©vite la division par z√©ro
                const formattedPercentage = percentageDifference.toFixed(1) + "%";
    
                // Calcul du pourcentage de montant2 du domaine par rapport au total montant1
                const percentageCA = totalMontant2 === 0 ? 0 : (d.montant2 / totalMontant1) * 100;
                const formattedPercentageCA = percentageCA.toFixed(1) + "%";
    
                const percentRentRecette = d.montant1 === 0 ? 0 : (difference / d.montant1) * 100;  // pas de division par z√©ro
                const formattedRentRecette = percentRentRecette.toFixed(1) + "%";
    
                // Cr√©ation de la barre pour 'montant1' CA
                agencesGroup.append("rect")
                    .attr("x", x(currentX1))
                    .attr("y", 0)
                    .attr("width", x(d.montant1) - x(0))
                    .attr("height", barHeight / 2)
                    .attr("fill", getDomainColor(d.agence, d.domaine, data))
                    .append("title")
                    .text(
                        d.agence + " - " + d.domaine +
                        " - Recette : " + new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(d.montant1) + "‚Ç¨" +
                        " | Rentabilit√© - " + d.domaine + " : " + (difference >= 0 ? "+" : "") + formattedRentRecette +
                        " | Rentabilit√© - " + d.agence + " : " + (differenceAgence >= 0 ? "+" : "") + formattedRentabiliteRecette
                    );
                currentX1 += d.montant1;
            
                // Cr√©ation de la barre pour 'montant2' D√©penses
                agencesGroup.append("rect")
                    .attr("x", x(currentX2))
                    .attr("y", 20)
                    .attr("width", x(d.montant2) - x(0))
                    .attr("height", barHeight / 2)
                    .attr("fill", getDomainColor(d.agence, d.domaine, data))
                    .append("title")
                    .text(
                        d.agence + " - " + d.domaine +
                        " - D√©penses : " + new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(d.montant2) + "‚Ç¨" +
                        " | Rentabilit√© - " + d.domaine + " : " + (difference >= 0 ? "+" : "") + formattedPercentage +
                        " | Rentabilit√© - " + d.agence + " : " + (differenceAgence >= 0 ? "+" : "") + formattedPercentageAgence +
                        " | Proportion du CA : " + formattedPercentageCA
                    );
    
                currentX2 += d.montant2;
            });
            
        });
    
        // Ajout des axes X et Y avec le `marginLeft` dynamique
        svg.append("g")
        .attr("transform", "translate(0," + marginTop + ")")
        .call(d3.axisTop(x).ticks(width / 100 + 2, "s")) // Ajout d'une 1 graduation √© la fin
        .call(g => g.selectAll(".domain").remove());
    
        svg.append("g")
            .attr("transform", "translate(" + marginLeft + ",0)")
            .call(d3.axisLeft(y).tickSizeOuter(0))
            .call(g => g.selectAll(".domain").remove());
    
        // L√©gende dynamique pour les domaines sous chaque agence
        const legendContainer = d3.select("#legend-container");
        legendContainer.html(""); // Pour vider le contenu de la l√©gende avant de la remplir
        
        agences.forEach(agence => {
            const agencyLegend = legendContainer.append("div")
                .attr("class", "agency-legend")
                .style("margin", "10px 0")
                .style("padding", "10px")
                .style("width", "90%")
                .style("border-radius", "5px")
                .style("background-color", "#f9f9f9");
        
            // Titre de l'agence
            agencyLegend.append("div")
                .attr("class", "agency-title")
                .style("font-weight", "bold")
                .style("font-size", "14px")
                .style("margin-bottom", "8px")
                .text(agence);
        
            // Filtrer les donn√©es pour l'agence actuelle
            const agenceData = data.filter(d => d.agence === agence);
        
            // Conteneur pour les domaines
            const domainesContainer = agencyLegend.append("div")
                .attr("class", "domaines-container")
                .style("display", "flex")
                .style("flex-direction", "column");
        
            // Parcourir les domaines et ajout des informations
            agenceData.forEach(d => {
                
                domainesContainer.append("div")
                .attr("class", "domaine-item")
                .style("display", "flex")
                .style("align-items", "left")
                .style("margin-bottom", "5px")
                .each(function () {
                    // V√©rification si le domaine n'est pas vide
                    // const domainColor = color(d.domaine) ? color(d.domaine) : "#ccc";
                    // V√©rification si le domaine est d√©fini et r√©cup√©ration de sa couleur
                    const domainColor = getDomainColor(d.agence, d.domaine, data);
                    // Carr√© de couleur pour le domaine avec taille fixe
                    d3.select(this).append("div")
                        .style("width", "15px")    // Taille fixe du carr√©
                        .style("height", "15px")   // Taille fixe du carr√©
                        .style("background-color", domainColor)
                        .style("margin-right", "10px")
                        .style("flex-shrink", "0"); // Emp√©che le carr√© de se r√©tr√©cir
            
                    // Abr√©viation du domaine
                    // const abbrDomaine = d.domaine.split(' ')
                    //     .map(word => word.slice(0, 3).toUpperCase()) 
                    //     .join(' ');
               
                    const abbrDomaine = creerAbbreviation(d.domaine);
                    
                    // Texte pour le domaine
                    d3.select(this).append("div")
                        .style("font-size", "11px")
                        .style("flex-grow", "1") 
                        .style("text-align", "left") 
                        .text(
                            abbrDomaine + " : CA " + formatMontant(d.montant1) + "‚Ç¨ - D√©p " + formatMontant(d.montant2) + "‚Ç¨"
                        );
                });
            });
        });
    }

    // Fonction pour cr√©er un graphique de type ligne 
    function createLineChart(dataReconstruct, selectedYear) {
        // Clear previous chart (to avoid duplicates)
        d3.select('svg').selectAll("*").remove();
        d3.select("#chart").selectAll(".selected-year-label").remove();
        
        
        // Calculate the number of months in the data
        let data = calculateMonthlyData(dataReconstruct);
        const numberOfMonths = data.length;

        // Adjust margins dynamically based on the number of months
        const margin = {
            top: 20,
            right: numberOfMonths > 11 ? 150 : 25, // Reduce margin if more than 10 months
            bottom: 40,
            left: 60
        };

        // Chart dimensions
        const chartWidth = Math.min(700, window.innerWidth - margin.left - margin.right);
        const chartHeight = 500 - margin.top - margin.bottom;

        // Parse date
        const parseDate = d3.timeParse("%Y-%m");
        data.forEach(d => {
        d.date = parseDate(d.date);
        });

    

    // Create SVG container
    const svg = d3
        .select('svg')
        .attr('width', chartWidth + margin.left + margin.right)
        .attr('height', chartHeight + margin.top + margin.bottom)
        .attr("viewBox", `0 0 ${chartWidth + margin.left + margin.right} ${chartHeight + margin.top + margin.bottom}`)
        .attr("style", "max-width: 100%; height: auto;")
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

    // X scale
    // let xScale = d3
    //   .scaleTime()
    //   .domain(d3.extent(data, d => d.date))
    //   .range([0, chartWidth]);

    // Les mois de l'ann√©e s√©lectionn√©e
        const generateYearMonths = (year) => {
        const months = [];
        for (let i = 0; i < 12; i++) {
            months.push(new Date(year, i, 1)); // On g√©n√®re le 1er jour de chaque mois
        }
        return months;
        };

    // Generate months for a period
    const generateYearMonthsPeriode = (startDateStr, endDateStr) => {
            const months = [];
            const startDate = new Date(startDateStr.split('-').reverse().join('-'));
            const endDate = new Date(endDateStr.split('-').reverse().join('-'));
            let currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                months.push(new Date(currentDate));
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            return months;
        };

        // Generate fullYearMonths based on selectedYear
        let fullYearMonths;
        if (selectedYear.length > 5) {
            const [startDate, endDate] = selectedYear.split(' - ').map(date => date.trim());
            fullYearMonths = generateYearMonthsPeriode(startDate, endDate);
        } else {
            fullYearMonths = generateYearMonths(selectedYear);
        }
    
    // X scale
    const xScale = d3
        .scaleTime()
        // .domain([new Date(selectedYear, 0, 1), new Date(selectedYear, 11, 31)]) 
        .domain([fullYearMonths[0], fullYearMonths[fullYearMonths.length - 1]])
        .range([0, chartWidth]);

    // Extract field keys
    const fieldKeys = Object.keys(data[0]).filter(key => key !== 'date');
    // Y scale
    const yScale = d3
        .scaleLinear()
        .domain([0, d3.max(data, d => Math.max(...fieldKeys.map(key => d[key])))]).nice()
        .range([chartHeight, 0]);

    // Create a color palette by agency
    const agencies = [...new Set(fieldKeys.map(key => key.split(" : ")[1]))]; // Extract unique agency names
    const colorPalette = d3.scaleOrdinal(d3.schemeTableau10).domain(agencies);


    // Prepare line data
    const lineData = fieldKeys.map((field) => ({
        key: field,
        agency: field.split(" : ")[1], // Extract the agency name
        type: field.split(" : ")[0], // Extract the type ("CA" or "D√©penses")
        color: colorPalette(field.split(" : ")[1]), // Assign color by agency
        data: data.map(d => ({ date: d.date, value: d[field] })),
    }));

    // Line generator
    const lineGenerator = d3
        .line()
        .curve(d3.curveCatmullRom)
        .x(d => xScale(d.date))
        .y(d => yScale(d.value));

    // Format currency (‚Ç¨)
    const formatCurrency = d3.format(".2f");

    // Store visibility state of each curve
    let visibilityState = {};

    // Tooltip creation
    const tooltip = d3.select('body')
        .append('div')
        .style('position', 'absolute')
        .style('background', '#fff')
        .style('border', '1px solid #ccc')
        .style('padding', '8px')
        .style('border-radius', '4px')
        .style('box-shadow', '0px 2px 4px rgba(0, 0, 0, 0.1)')
        .style('visibility', 'hidden')
        .style('font-size', '12px');

    // Drag behavior for labels
    const drag = d3.drag()
        .on("drag", function (event, d) {
        const draggedX = event.x; // Position relative to SVG's origin
        const draggedY = event.y;

        // Update label position
        d3.select(this)
            .attr("x", draggedX)
            .attr("y", draggedY);
        });

    // Area generator for the "gap" between CA and D√©penses
    const areaGenerator = d3
        .area()
        .curve(d3.curveCatmullRom)
        .x(d => xScale(d.date))
        .y0(d => yScale(d.ca)) // Start at CA
        .y1(d => yScale(d.depenses)); // End at D√©penses


    // Add lines and labels
    lineData.forEach(d => {
        // To determine if the line is for "CA" or "D√©penses"
        const isCA = d.type === "CA";
        const isDepenses = d.type === "D√©penses";

        // Style specific for "D√©penses" (dashed line)
        const strokeDasharray = isDepenses ? "4 4" : "none";

        // Draw line
        const line = svg
        .append('path')
        .datum(d.data)
        .attr('class', 'line')
        .attr('d', lineGenerator)
        .attr('stroke', d.color) 
        .attr('fill', 'none')
        .attr('stroke-width', 2)
        .attr('stroke-dasharray', strokeDasharray) 
        .style('visibility', 'visible'); 
        // Show tooltip on mouseover
        svg.selectAll('.line')
            .data(lineData) // Associe chaque ligne √† ses donn√©es correspondantes
            .on('mouseover', function (event, d) {
            // Le point le plus proche sur la ligne
            const [mouseX] = d3.pointer(event, this); // R√©cup√®re la position X de la souris relative √† l'√©l√©ment
            const closestPoint = d.data.reduce((prev, curr) => {
                const currDistance = Math.abs(xScale(curr.date) - mouseX);
                const prevDistance = Math.abs(xScale(prev.date) - mouseX);
                return currDistance < prevDistance ? curr : prev;
            });

            // Affichage de tooltip
            tooltip.style('visibility', 'visible')
            .style('top', `${event.pageY - 40}px`)
            .style('left', `${event.pageX + 10}px`)
            .html(`
                <strong>${d.key}</strong><br>
                Date: ${d3.timeFormat("%b %Y")(closestPoint.date)}<br>
                Montant: ‚Ç¨${formatCurrency(closestPoint.value)}
            `);

        
            svg.selectAll('.line')
            .style('opacity', function () {
                return this === event.target ? 1 : 0.4; // Mise en √©vidence la ligne survol√©e
            });
        })
        .on('mousemove', function (event) {
            // Meise √† jour dynamiquement la position du tooltip
            tooltip.style('top', `${event.pageY - 40}px`)
            .style('left', `${event.pageX + 10}px`);
        })
        .on('mouseout', function () {
            // Cache le tooltip
            tooltip.style('visibility', 'hidden');

            // R√©initialisation de l'opacit√© de toutes les lignes
            svg.selectAll('.line')
            .style('opacity', 1);
        });


        // Initialize visibility state
        visibilityState[d.key] = true;

        // Get the last point of the curve
        const lastPoint = d.data[d.data.length - 1];
        const xPosition = xScale(lastPoint.date);
        const yPosition = yScale(lastPoint.value);

        // Adding a point if there is only one data point
        if (d.data.length === 1) {
                const points = svg.selectAll('.point')
                svg.append('circle')
                .attr('class', 'point')
                .attr('cx', xPosition)
                .attr('cy', yPosition)
                .data(d.data)
                .attr('class', d => `point-${d.key}`)
                .attr('r', 5) // Rayon du point
                .attr('fill', d.color) 
                .attr('stroke', d.color) 
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', strokeDasharray) 
                .attr('stroke-width', 4.5)
                .style('visibility', 'visible');
                
                svg.selectAll('.label')
                    .data(d.data)
                    .enter()
                    .append('text')
                    .text(`${d.key} (‚Ç¨${formatMontant(formatCurrency(lastPoint.value))})`)
                    .attr('x', xPosition + 5)
                    .attr('y', yPosition - 5)
                    .attr('text-anchor', 'start')
                    .style('font-family', 'sans-serif')
                    .style('font-size', '12px')
                    .style('fill', d.color)
                    .style('font-weight', 'bold')
                    .call(drag)
                    .on('click', function(event, d) {
                        // Basculer l'√©tat de visibilit√© pour la ligne et les points
                        const isVisible = visibilityState[d.key];
                        visibilityState[d.key] = !isVisible;
                        
                        // Met √† jour la visibilit√© de la ligne
                        line.style('visibility', visibilityState[d.key] ? 'visible' : 'hidden');

                        // Met √† jour la visibilit√© des points associ√©s (y compris les points entill√©s)
                        svg.selectAll(`.point-${d.key}`).style('visibility', visibilityState[d.key] ? 'visible' : 'hidden');

                        // Basculer l'effet de strikethrough sur le libell√©
                        const labelText = d3.select(this);
                        labelText.style('text-decoration', visibilityState[d.key] ? 'none' : 'line-through');
                });
        }else {
            // Add the label
            svg.append('text')
            .text(`${d.key} (‚Ç¨${formatMontant(formatCurrency(lastPoint.value))})`)
            .attr('x', xPosition + 5)
            .attr('y', yPosition - 5)
            .attr('text-anchor', 'start')
            .style('font-family', 'sans-serif')
            .style('font-size', '12px')
            .style('fill', d.color)
            .style('font-weight', 'bold')
            .call(drag)
            .on('click', function () {
                // Bascule de l'√©tat de visibilit√© pour la ligne et le point
                const isVisible = visibilityState[d.key];
                visibilityState[d.key] = !isVisible;
            
                // Met √† jour la visibilit√© de la ligne et du point
                line.style('visibility', visibilityState[d.key] ? 'visible' : 'hidden');

                // Basculer l'effet de strikethrough sur le libell√©
                const labelText = d3.select(this);
                labelText.style('text-decoration', visibilityState[d.key] ? 'none' : 'line-through');
            });
        }
        });

    // Add areas for each agency
    // Add areas for each agency
    agencies.forEach(agency => {
        const caData = lineData.find(d => d.type === "CA" && d.agency === agency);
        const depensesData = lineData.find(d => d.type === "D√©penses" && d.agency === agency);

        if (caData && depensesData) {
        const combinedData = caData.data.map((d, i) => ({
            date: d.date,
            ca: d.value,
            depenses: depensesData.data[i]?.value || 0,
        }));

        const area = svg.append("path")
            .datum(combinedData)
            .attr("class", "area")
            .attr("d", areaGenerator)
            .attr("fill", caData.color) 
            .attr("fill-opacity", 0.1) // Semi-transparent fill for the areas
            .style("cursor", "pointer");

        // Add tooltip and hover effect
        area.on("mouseover", function () {
            // Highlight the area
            d3.select(this)
                .attr("fill-opacity", 0.3); 

            // Show tooltip
            tooltip.style("visibility", "visible");
            })
            .on("mousemove", function (event, d) {
            // Get mouse position relative to the chart
            const [mouseX] = d3.pointer(event, this);
            const hoveredDate = xScale.invert(mouseX); // Convert mouseX to a date

            // Find the closest data point
            const closestPoint = d.reduce((prev, curr) => {
                const prevDistance = Math.abs(prev.date - hoveredDate);
                const currDistance = Math.abs(curr.date - hoveredDate);
                return currDistance < prevDistance ? curr : prev;
            });

            // Update tooltip content
            tooltip.style("top", `${event.pageY - 40}px`)
                .style("left", `${event.pageX + 10}px`)
                .html(`
                <strong>${agency}</strong><br>
                Date: ${d3.timeFormat("%b %Y")(closestPoint.date)}<br>
                CA: ‚Ç¨${formatCurrency(closestPoint.ca)}<br>
                D√©penses: ‚Ç¨${formatCurrency(closestPoint.depenses)}<br>
                R√©sultat: ${(closestPoint.ca - closestPoint.depenses).toFixed(2)}<br>
                R√©sultat en %: ${((closestPoint.ca - closestPoint.depenses) / closestPoint.ca * 100).toFixed(2)}%
            `);
            })
            .on("mouseout", function () {
            // Reset the area opacity
            d3.select(this)
                .attr("fill-opacity", 0.1); // Reset to default opacity

            // Hide tooltip
            tooltip.style("visibility", "hidden");
            });
        }
    });

    // Adding X axis
    // const xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%b %Y"));
    // svg.append('g').attr('transform', `translate(0,${chartHeight})`).call(xAxis);
    
    
        let xAxis = null;
        if (selectedYear.length > 5) {
            // Calculer l'intervalle de mois en fonction de l'espace disponible
            const tickSpacing = chartWidth / fullYearMonths.length; // Largeur de chaque tick (mois)
            const monthStep = tickSpacing > 60 ? 1 : tickSpacing > 30 ? 2 : 3; // Choisir d'afficher 1 mois, 2 mois ou 3 mois en fonction de l'espace


            // D√©finir les valeurs de ticks pour l'axe X (en sautant certains mois)
            const tickValues = fullYearMonths.filter((month, index) => index % monthStep === 0);

            // Cr√©er l'axe X
        xAxis = d3.axisBottom(xScale)
            .tickFormat(d => d3.timeFormat("%b %Y")(d)) // Format du mois et de l'ann√©e (janv 2025)
            .tickValues(tickValues);
        } else {
        // Adding X axis
            xAxis = d3.axisBottom(xScale)
            .tickFormat(d => d3.timeFormat("%b %Y")(d)) // Format "janv 2025"
            .tickValues(fullYearMonths); // Affichage de tous les mois explicitement
        }

        svg.append('g')
            .attr('transform', `translate(0,${chartHeight})`)
            .call(xAxis);


        svg.append('g')
            .attr('transform', `translate(0,${chartHeight})`)
            .call(xAxis);

        // Adding Y axis
        const yAxis = d3.axisLeft(yScale);
        svg.append('g').call(yAxis);

        const fontSize = selectedYear.length > 5 ? "14px" : "20px"; // Si la longueur est > 5, font-size = 8px, sinon 20px
        let displayText = selectedYear;
            if (selectedYear.length > 5) {
                // Split √† l'endroit du tiret pour retourner √† la ligne
                const parts = selectedYear.split(' - ');
                displayText = ' P√©riode : ' + parts[0] + " - "  + parts[1];  
            }

        // Adding label for the selected year on the Y-axis
        svg.append("text")
            .attr("x", chartWidth - 40) 
            .attr("y", chartHeight + 40) 
            .attr("class", "selected-year-label")
            .style("font-size", fontSize)
            .style("font-weight", "600")
            .style("font-family", "'Poppins', sans-serif")
            .style("fill", "#0056b3")
            .style("text-anchor", "middle")
            .text('üìÖ' + displayText);

        createLegend(lineData);
    }

    // Fonction de l√©gende
    function createLegend(lineData) {
        const legendContainer = d3.select("#legend-container");
        const visibilityState = {}; // Suivi de la visibilit√©
    
        legendContainer.html(""); // Clear previous legend
    
        // On regroupe les donn√©es pour chaque agence
        const agencies = {};
    
        lineData.forEach(d => {
        const agencyName = d.key.split(" : ")[1]; // Extrait le nom de l'agence
        visibilityState[d.key] = true; // Initialement visible
    
        if (!agencies[agencyName]) {
            agencies[agencyName] = {
            caColor: 0,
            depensesColor: 0,
            caValue: 0,
            depensesValue: 0,
            };
        }
    
        if (d.key.includes("CA")) {
            agencies[agencyName].caValue = d.data[d.data.length - 1].value;
            agencies[agencyName].caColor = d.color;
        } else if (d.key.includes("D√©penses")) {
            agencies[agencyName].depensesValue = d.data[d.data.length - 1].value;
            agencies[agencyName].depensesColor = d.color;
        }
        });
    
        Object.keys(agencies).forEach(agencyName => {
        const entry = legendContainer.append("div")
            .attr("class", "agency-legend")
            .style("margin", "10px 0")
            .style("padding", "10px")
            .style("width", "90%")
            .style("border-radius", "5px")
            .style("background-color", "#f9f9f9")
            .style("display", "flex")
            .style("flex-direction", "column")
            .style("align-items", "left");
    
        entry.append("span")
            .text(agencyName)
            .attr("class", "agency-title")
            .style("font-weight", "bold")
            .style("font-size", "14px")
            .style("margin-bottom", "8px")
            .style("text-align", "center");
    
        const caSection = entry.append("div")
            .style("display", "flex")
            .style("align-items", "left")
            .style("margin-bottom", "5px");
    
        caSection.append("span")
            .style("width", "15px")
            .style("height", "15px")
            .style("background-color", agencies[agencyName].caColor) // Couleur pleine pour "CA"
            .style("display", "inline-block")
            .style("margin-right", "10px");
    
        caSection.append("span")
            .text(`CA : ‚Ç¨${d3.format(".2f")(agencies[agencyName].caValue)}`)
            .style("font-size", "14px");
    
        caSection.on("click", function() {
            const key = `CA : ${agencyName}`;
            visibilityState[key] = !visibilityState[key];
    
            const line = d3.selectAll('.line').filter(function() {
            return d3.select(this).attr('data-key') === key;
            });
    
            // if (visibilityState[key]) {
            //   d3.select(this).style("text-decoration", "none");
            //   line.style("visibility", "visible");
            // } else {
            //   d3.select(this).style("text-decoration", "line-through");
            //   line.style("visibility", "hidden");
            // }
        });
    
        const depensesSection = entry.append("div")
            .style("display", "flex")
            .style("align-items", "left");
    
        depensesSection.append("span")
            .style("width", "15px")
            .style("height", "15px")
            .style("background-image", `repeating-linear-gradient(
            45deg,
            ${agencies[agencyName].depensesColor},
            ${agencies[agencyName].depensesColor} 5px,
            transparent 5px,
            transparent 10px
            )`) // Hachures pour "D√©penses"
            .style("display", "inline-block")
            .style("margin-right", "10px");
    
        depensesSection.append("span")
            .text(`D√©penses : ‚Ç¨${d3.format(".2f")(agencies[agencyName].depensesValue)}`)
            .style("font-size", "14px");
    
        depensesSection.on("click", function() {
            const key = `D√©penses : ${agencyName}`;
            visibilityState[key] = !visibilityState[key];
    
            const line = d3.selectAll('.line').filter(function() {
            return d3.select(this).attr('data-key') === key;
            });
    
            // if (visibilityState[key]) {
            //   d3.select(this).style("text-decoration", "none");
            //   line.style("visibility", "visible");
            // } else {
            //   d3.select(this).style("text-decoration", "line-through");
            //   line.style("visibility", "hidden");
            // }
        });
        });
    }
  
    function last(array) {
        return array[array.length - 1];
    }




    
    
    

